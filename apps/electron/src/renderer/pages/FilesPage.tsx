/**
 * FilesPage - Workspace files browser
 *
 * Shows files organized by type:
 * - Created: Files in the workspace working directory (generated by AI)
 * - Uploaded: Files attached by the user to conversations
 */

import * as React from 'react'
import { useState, useEffect, useCallback, useMemo } from 'react'
import { useAtomValue } from 'jotai'
import { formatDistanceToNow } from 'date-fns'
import {
  FileCode,
  FileText,
  Globe,
  Table,
  Image,
  File,
  Folder,
  Paperclip,
  ExternalLink,
  Sparkles,
  Upload,
  RefreshCw,
} from 'lucide-react'
import { cn } from '@/lib/utils'
import { PanelHeader } from '@/components/app-shell/PanelHeader'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Button } from '@/components/ui/button'
import { useAppShellContext } from '@/context/AppShellContext'
import { sessionIdsAtom, sessionMetaMapAtom, sessionAtomFamily } from '@/atoms/sessions'
import type { SessionFile, StoredAttachment } from '../../shared/types'

// =============================================================================
// Types
// =============================================================================

interface FlatFile {
  name: string
  path: string
  size?: number
  type: 'code' | 'web' | 'document' | 'data' | 'image' | 'other'
  ext: string
}

interface AggregatedAttachment extends StoredAttachment {
  sessionId: string
  sessionName?: string
  timestamp: number
}

// =============================================================================
// Helper Functions
// =============================================================================

function getFileType(filename: string): FlatFile['type'] {
  const ext = filename.split('.').pop()?.toLowerCase() || ''

  if (['ts', 'tsx', 'js', 'jsx', 'py', 'rb', 'go', 'rs', 'java', 'c', 'cpp', 'h', 'swift', 'kt', 'sh', 'bash'].includes(ext)) {
    return 'code'
  }
  if (['html', 'htm', 'css', 'scss', 'sass', 'less', 'vue', 'svelte'].includes(ext)) {
    return 'web'
  }
  if (['md', 'mdx', 'txt', 'doc', 'docx', 'pdf', 'rtf'].includes(ext)) {
    return 'document'
  }
  if (['json', 'yaml', 'yml', 'xml', 'csv', 'xlsx', 'xls', 'toml'].includes(ext)) {
    return 'data'
  }
  if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'ico', 'bmp'].includes(ext)) {
    return 'image'
  }
  return 'other'
}

function getFileIcon(type: FlatFile['type']) {
  const iconClass = "h-4 w-4"
  switch (type) {
    case 'code':
      return <FileCode className={iconClass} />
    case 'web':
      return <Globe className={iconClass} />
    case 'document':
      return <FileText className={iconClass} />
    case 'data':
      return <Table className={iconClass} />
    case 'image':
      return <Image className={iconClass} />
    default:
      return <File className={iconClass} />
  }
}

function getFileColor(type: FlatFile['type']): string {
  switch (type) {
    case 'code':
      return 'text-violet-500 bg-violet-500/10'
    case 'web':
      return 'text-blue-500 bg-blue-500/10'
    case 'document':
      return 'text-emerald-500 bg-emerald-500/10'
    case 'data':
      return 'text-orange-500 bg-orange-500/10'
    case 'image':
      return 'text-pink-500 bg-pink-500/10'
    default:
      return 'text-foreground/50 bg-foreground/5'
  }
}

function getFileTypeLabel(type: FlatFile['type']): string {
  switch (type) {
    case 'code':
      return 'Code'
    case 'web':
      return 'Web'
    case 'document':
      return 'Document'
    case 'data':
      return 'Data'
    case 'image':
      return 'Image'
    default:
      return 'File'
  }
}

function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`
}

// Flatten file tree into a list of files (no directories)
function flattenFiles(files: SessionFile[], basePath: string = ''): FlatFile[] {
  const result: FlatFile[] = []

  for (const file of files) {
    if (file.type === 'directory' && file.children) {
      result.push(...flattenFiles(file.children, file.path))
    } else if (file.type === 'file') {
      const ext = file.name.split('.').pop()?.toLowerCase() || ''
      result.push({
        name: file.name,
        path: file.path,
        size: file.size,
        type: getFileType(file.name),
        ext,
      })
    }
  }

  return result
}

// =============================================================================
// Section Components
// =============================================================================

function SectionHeader({
  title,
  count,
  icon: Icon,
}: {
  title: string
  count?: number
  icon: React.ComponentType<{ className?: string }>
}) {
  return (
    <div className="flex items-center gap-2 mb-3 mt-6 first:mt-0">
      <Icon className="h-3.5 w-3.5 text-foreground/30" />
      <h2 className="text-[11px] font-semibold uppercase tracking-wider text-foreground/40">
        {title}
      </h2>
      {count !== undefined && count > 0 && (
        <span className="text-[10px] text-foreground/30 bg-foreground/5 rounded-full px-1.5 py-0.5 tabular-nums">
          {count}
        </span>
      )}
    </div>
  )
}

function EmptyState({
  icon: Icon,
  title,
  description
}: {
  icon: React.ComponentType<{ className?: string }>
  title: string
  description: string
}) {
  return (
    <div className="flex flex-col items-center justify-center py-8 px-4 text-center">
      <div className="h-10 w-10 rounded-full bg-foreground/[0.03] flex items-center justify-center mb-3">
        <Icon className="h-5 w-5 text-foreground/20" />
      </div>
      <p className="text-[13px] font-medium text-foreground/50 mb-1">{title}</p>
      <p className="text-[11px] text-foreground/30 max-w-[240px]">{description}</p>
    </div>
  )
}

// =============================================================================
// File Card Components
// =============================================================================

interface FileCardProps {
  file: FlatFile
  onClick?: () => void
}

function FileCard({ file, onClick }: FileCardProps) {
  const colorClass = getFileColor(file.type)

  return (
    <button
      onClick={onClick}
      className={cn(
        "group relative flex flex-col p-4 rounded-xl border border-foreground/[0.06]",
        "bg-foreground/[0.015] hover:bg-foreground/[0.03] hover:border-foreground/10",
        "transition-all duration-150 text-left w-full",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
      )}
    >
      {/* Icon & Type Badge */}
      <div className="flex items-start justify-between mb-3">
        <div className={cn("h-9 w-9 rounded-lg flex items-center justify-center", colorClass)}>
          {getFileIcon(file.type)}
        </div>
        <span className="text-[10px] font-medium text-foreground/30 uppercase tracking-wide">
          {file.ext || getFileTypeLabel(file.type)}
        </span>
      </div>

      {/* Title */}
      <h3 className="text-[13px] font-medium text-foreground mb-1 line-clamp-2 leading-snug">
        {file.name}
      </h3>

      {/* Metadata */}
      <div className="flex items-center gap-2 mt-auto pt-2">
        {file.size !== undefined && (
          <span className="text-[11px] text-foreground/30">
            {formatFileSize(file.size)}
          </span>
        )}
      </div>

      {/* Hover indicator */}
      <div className="absolute top-3 right-3 opacity-0 group-hover:opacity-100 transition-opacity">
        <ExternalLink className="h-3.5 w-3.5 text-foreground/30" />
      </div>
    </button>
  )
}

interface UploadedFileCardProps {
  file: AggregatedAttachment
  onClick?: () => void
}

function UploadedFileCard({ file, onClick }: UploadedFileCardProps) {
  const isImage = file.mimeType.startsWith('image/')
  const isPdf = file.mimeType === 'application/pdf'

  return (
    <button
      onClick={onClick}
      className={cn(
        "group flex items-center gap-3 p-3 rounded-lg",
        "hover:bg-foreground/[0.03] transition-colors w-full text-left",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
      )}
    >
      {/* Icon */}
      <div className={cn(
        "h-10 w-10 rounded-lg flex items-center justify-center shrink-0",
        isImage ? "text-pink-500 bg-pink-500/10" :
        isPdf ? "text-red-500 bg-red-500/10" :
        "text-foreground/40 bg-foreground/5"
      )}>
        {isImage ? <Image className="h-4 w-4" /> :
         isPdf ? <FileText className="h-4 w-4" /> :
         <Paperclip className="h-4 w-4" />}
      </div>

      {/* Info */}
      <div className="flex-1 min-w-0">
        <p className="text-[13px] font-medium text-foreground truncate">{file.name}</p>
        <div className="flex items-center gap-2 text-[11px] text-foreground/40">
          <span>{formatFileSize(file.size)}</span>
          {file.sessionName && (
            <>
              <span className="text-foreground/20">Â·</span>
              <span className="truncate">{file.sessionName}</span>
            </>
          )}
        </div>
      </div>

      {/* Timestamp */}
      <span className="text-[11px] text-foreground/30 shrink-0">
        {formatDistanceToNow(file.timestamp, { addSuffix: true })}
      </span>
    </button>
  )
}

// =============================================================================
// Custom Hooks
// =============================================================================

function useAllAttachments(): AggregatedAttachment[] {
  const sessionIds = useAtomValue(sessionIdsAtom)
  const sessionMetaMap = useAtomValue(sessionMetaMapAtom)

  // Read each session to get messages with attachments
  const sessionData = sessionIds.map(sessionId => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const session = useAtomValue(sessionAtomFamily(sessionId))
    return { sessionId, session }
  })

  return useMemo(() => {
    const allAttachments: AggregatedAttachment[] = []

    for (const { sessionId, session } of sessionData) {
      if (!session?.messages) continue

      const meta = sessionMetaMap.get(sessionId)
      const sessionName = meta?.name || meta?.preview?.slice(0, 30)

      for (const message of session.messages) {
        if (message.role === 'user' && message.attachments) {
          for (const attachment of message.attachments) {
            allAttachments.push({
              ...attachment,
              sessionId,
              sessionName,
              timestamp: message.timestamp,
            })
          }
        }
      }
    }

    // Sort by most recent
    return allAttachments.sort((a, b) => b.timestamp - a.timestamp)
  }, [sessionData, sessionMetaMap])
}

// =============================================================================
// Main Component
// =============================================================================

export default function FilesPage() {
  const { workspaces, activeWorkspaceId } = useAppShellContext()
  const [files, setFiles] = useState<FlatFile[]>([])
  const [workingDirectory, setWorkingDirectory] = useState<string | null>(null)
  const [loading, setLoading] = useState(true)
  const attachments = useAllAttachments()

  // Load workspace settings and files
  const loadFiles = useCallback(async () => {
    if (!activeWorkspaceId) {
      setLoading(false)
      return
    }

    setLoading(true)

    try {
      // Get workspace settings to find working directory
      const settings = await window.electronAPI.getWorkspaceSettings(activeWorkspaceId)
      const workDir = settings?.workingDirectory

      if (!workDir) {
        setWorkingDirectory(null)
        setFiles([])
        setLoading(false)
        return
      }

      setWorkingDirectory(workDir)

      // Scan the working directory
      const scannedFiles = await window.electronAPI.scanDirectory(workDir)
      const flatFiles = flattenFiles(scannedFiles)

      // Sort by name
      flatFiles.sort((a, b) => a.name.localeCompare(b.name))
      setFiles(flatFiles)
    } catch (err) {
      console.error('Failed to load files:', err)
    } finally {
      setLoading(false)
    }
  }, [activeWorkspaceId])

  // Load files on mount and when workspace changes
  useEffect(() => {
    loadFiles()
  }, [loadFiles])

  // Handle opening a file
  const handleOpenFile = (path: string) => {
    window.electronAPI.openFile(path)
  }

  // Handle refresh
  const handleRefresh = () => {
    loadFiles()
  }

  return (
    <div className="flex flex-col h-full">
      <PanelHeader
        title="Files"
        actions={
          <Button
            variant="ghost"
            size="sm"
            onClick={handleRefresh}
            disabled={loading}
            className="h-7 w-7 p-0"
          >
            <RefreshCw className={cn("h-3.5 w-3.5", loading && "animate-spin")} />
          </Button>
        }
      />

      <ScrollArea className="flex-1 min-h-0">
        <div className="px-4 pb-6 pt-2">
          {/* Created Section */}
          <SectionHeader title="Created" count={files.length} icon={Sparkles} />

          {loading ? (
            <div className="flex items-center justify-center py-8">
              <RefreshCw className="h-5 w-5 text-foreground/30 animate-spin" />
            </div>
          ) : !workingDirectory ? (
            <EmptyState
              icon={Folder}
              title="No working directory"
              description="Set a working directory in workspace settings to see created files"
            />
          ) : files.length === 0 ? (
            <EmptyState
              icon={Sparkles}
              title="No files yet"
              description="Files created by the AI in your workspace will appear here"
            />
          ) : (
            <div className="grid grid-cols-2 gap-3">
              {files.map((file) => (
                <FileCard
                  key={file.path}
                  file={file}
                  onClick={() => handleOpenFile(file.path)}
                />
              ))}
            </div>
          )}

          {/* Uploaded Section */}
          <SectionHeader title="Uploaded" count={attachments.length} icon={Upload} />

          {attachments.length === 0 ? (
            <EmptyState
              icon={Upload}
              title="No uploaded files yet"
              description="Files you attach to messages will appear here"
            />
          ) : (
            <div className="flex flex-col">
              {attachments.map((file) => (
                <UploadedFileCard
                  key={`${file.sessionId}-${file.id}`}
                  file={file}
                  onClick={() => file.storedPath && handleOpenFile(file.storedPath)}
                />
              ))}
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  )
}
